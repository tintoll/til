#객체지향과 디자인 패턴

##Chapter2 객체 지향
1.1 절차지향은 데이터를 중심으로 한 프로시저로 구성되어 있다.
1.2 객체지향은 데이터 및 데이터와 관련된 프로시저를 객체라고 불리는 단위로 묶는다.

2.1 객체의 핵심은 기능을 제공하는 것
2.3 객체의 책임과 크기
 - 객체가 갖는 책임의 크기는 작을수록 좋다. 가장 어려우면서도 가장 중요한 것이 바로 객체마다 기능을 할당하는 과정이다.
 - 객체가 많은 기능을 가지면 절차지향적(데이터중심)으로 되기때문에 단일 책임원칙이 존재



4.의존
 - 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 의존 한다고 표현
 - 순환의존이 발생하지 않도록 하는 원칙이 의존역전 원칙(DIP)이다.
  예) A클래스 <- B클래스 <- C클래스 <- A클래스  = 순환의존

5.캡슐화
 - 객체지향의 장점은 한곳의 구현 변경이 다른 곳에 변경을 가하지 않도록 해준다는데 있다.
 - 캡슐화 : 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다.(내부 구현에대해 유연함을 제공해주는기법)
 - 캡슐화를 위한 두개의 규칙
   1. Tell, Don't Ask. 데이터를 물어보지 않고, 기능을 실행해 달라고 말하라
    * 기능 실행을 요청하는 방식으로 코드를 작성하는 버릇을 들여야 한다.
   2. 데미테르의 법칙(Law of Demeter)
    * 메서드에서 생성한 객체의 메서드만 호출
    * 파라미터로 받은 객체의 메서드만 호출
     ex) public void processSome(Member member){
	    if(member.getDate().getTime() < ...) //데미테르 법칙 위반
	 }
    * 필드로 참조하는 객체의 메서드만 호출

6.객체지향 설계과정
 1)제공해야 할 기능을 찾고 또는 세분화하고, 그 기능을 알맞은 객체에 할당한다.
  A.기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을수 있다.
  B.기능은 최대한 캡슐화해서 구현한다.
 2)객체 간에 어떻게 메시지를 주고 받을 지 결정한다.
 3)과정1과 과정2를 개발하는 동안 지속적으로 반복한다.
 ※ 외부구현에 대해 유연함을 제공해주는 방법이 추상화 이다.

## Chapter3 다형성과 추상 타입
- 객체 지향이 주는 장점은 구현 변경의 유연함이다. 외부 구현에 대해 유연함을 제공해는 추상화가 있고 이것을 가능하게 해주는것이 다형성이다.

1.상속(Inheritance)
 : 한 타입을 그대로 사용하면서 구현을 추가할 수 있도록 해주는 방법
 - 재정의(overriding) : 상위클래스에 정의된 메서드를 새롭게 구현하는 것.

2.다형성(Polymorphism)
 : 한 객체가 여러가지(poly)모습(morph)을 갖는 다는 것을 의미. 즉 한 객체가 여러타입을 가질 수 있다는 것을 뜻한다.

 - 자바와 같은 정적 타입 언어에서는 타입 상속을 통해서 다형성을 구현한다.
```
 	public class Plane{ public void fly(){ //비행 } }
     public interface Turbo { public void boost(); }
     public class TurboPlane extends Plane implements Turbo { public void boost(){ //가속 } }
     TurboPlane tp = new TurboPlane();
     Plane p = tp;  // TurboPlane 객체는 Plane 타입도 된다.
     p.fly();
     Turbo t = tp; // TurboPlane 객체는 Turbo 타입도 된다.
     t.boost();
 ```
 예)
 ```
 public class TurboPlane extends Plane { public void fly() { //재정의 } }
     Plane p = new TurboPlane();
     p.fly();	//실제 p의 타입인 TurboPlane의 fly() 실행 
 ```

3.추상화(abstraction)
 : 데이터나 프로세스 등을 의미가 비슷한 개념이나 표현으로 정의하는 과정이다.
 : 추상화는 공통된 개념을 도출해서 추상 타입을 정의해 주기도 하지만, 또한, 많은 책임을 가진 객체로부터 책임을 분리하는 촉매제가 되기도 한다.

 - 인터페이스의 정의된 기능을 실제로 구현하는데, 이들 클래스들은 실제 구현을 제공한다는 의미에서 '콘크리트 클래스(concrete class)'라고 부른다.


 ※ 클래스의 인스턴스를 한개로 제한 하기 위한 디자인 패턴인 싱글톤 패턴
  ex)
  ```
  private static ByteSourceFactory instance = new ByteSourceFactory();
      public static ByteSourceFactory getInstance(){
        return instance;
      }
  ```
※ 경험하지 않는 분야라 하더라고 추상화할 수 있는 방법이 있는데 그것은 바로 변화되는 부분을 추상화하는 것이다. 요구 사항이 바뀔때 변화되는 부분은 이후에도 변경될 소지가 많다. 이런 부분을 추상 타입으로 교체하면 향후 변경에 유연하게 대처할수 있는 가능성이 높아진다.

※ 인터페이스에 대고 프로그래밍하기(program to interface)
  : 실제 구현을 제공하는 콘크리트 클래스를 사용해서 프로그래밍하지 말고, 기능을 정의한 인터페이스를 사용해서 프로그래밍하라는 뜻이다.

※ 모든 곳에서 인터페이스를 사용해서는 안된다. 인터페이스를 사용해야 할 때는 변화 가능성이 높은 경우에 한해서 사용해야 한다.
※ 인터페이스를 작성할 때에는 그 인터페이스를 사용하는 코드 입장에서 작성해야 한다.

※ Mockito 사용법 - http://javacan.tistory.com/entry/MocktestUsingMockito

### Chapter4 재사용 : 상속보단 조립

1.상속을 통한 재사용의 단점
 1) 상위 클래스 변경의 어려움이 있다.
 2) 유사한 기능을 확장하는 과정에서 클래스의 개수가 불필요하게 증가할수 있다.
 3) 상속이 오용될수 있다.
   : 상속은 IS-A관계가 성립될 때에만 사용해야 하는데 그런 관계가 아닐때 사용한다.

2.조립을 이용한 재사용
 ※ 객체 조립(composition) : 여러 객체를 묶어서 더 복잡한 기능을 제공하는 객체를 만들어내는 것이다.
 ※ 상속보다는 객체 조립을 사용하는 것이 더 효과적이다.
 ※ 상속에 비해 조립을 통한 재사용의 단점은 상대적으로 런타임 구조가 복잡해진다. 그리고 상속보다 구현이 더 어렵다는데 있다. 하지만 장기적 관점에서 구현/구조의 복잡함보다 변경의 유연함을 확보하는 데서 오는 장점이 더 크기 때문에 기능을 재상용해야 할 경우 상속보다는 조립하는 방법을 먼저 고려해야 한다.
 ※ 위임(delegation) : 내가 할일을 다른 객체에 넘긴다는 의미를 담고 있으며, 보통 조립 방식을 이용해서 위임을 구현한다.

※ 상속은 언제 사용하나?
 - 재사용이라는 관점이 아닌 기능을 확장이라는 관점에서 상속을 적용해야하고 명확한 IS-A관계가 성립 할때 사용한다.

